+++
title = "Ruby data types"
date = 2025-08-29T20:03:08.939+01:00
draft = false
description = "In this part of the Ruby tutorial, we cover data types. A data type is a set of values, and the allowable operations on those values."
image = ""
imageBig = ""
categories = ["lang"]
authors = ["Cude"]
avatar = "/images/avatar.webp"
+++

[Contents](..)
[Previous](../objects/)
[Next](../strings/)

# Ruby data types

last modified October 18, 2023

In this part of the Ruby tutorial, we cover data types.

Computer programs of all sorts, including spreadsheets, text editors, calculators, and
chat clients, work with data. Tools to work with various data types are
essential part of a modern computer language. A *data type* is a set of
values, and the allowable operations on those values.

## Ruby data types list

Ruby has several data types. All data types are based on classes.
The following are the data types recognized in Ruby:

- Booleans

- Symbols

- Numbers

- Strings

- Arrays

- Hashes

In the following example, we have all important Ruby
data types.

types.rb
  

#!/usr/bin/ruby

h = { :name =&gt; "Jane", :age =&gt; 17 }

p true.class, false.class
p "Ruby".class
p 1.class
p 4.5.class
p 3_463_456_457.class
p :age.class
p [1, 2, 3].class
p h.class

We print their class names. A class is a template from each
object is created.

p true.class, false.class

The boolean values are presented by true and false objects.

p "Ruby".class

This is a string.

p 1.class
p 4.5.class
p 3_463_456_457.class

These are the numbers.

p :age.class

This is a symbol, a data type specific to Ruby.

p [1, 2, 3].class
p h.class

These are two containers, the array and the hash.

$ ./types.rb
TrueClass
FalseClass
String
Integer
Float
Integer
Symbol
Array
Hash

The program lists classes that belong to Ruby data types.

## Ruby Boolean values

There is a duality built in our world. There is a Heaven and Earth, water and
fire, jing and jang, man and woman, love and hatred. This is the 'boolean'
nature of our existence. In Ruby the boolean data type can have one of the two
values: true or false. Boolean is a fundamental data type: one that is very
common in computer programs.

Happy parents are waiting a child to be born. They have chosen a name for both
possibilities. If it is going to be a boy, they have chosen John. If it is going
to be a girl, they have chosen Victoria.

random_name.rb
  

#!/usr/bin/ruby

# random_name.rb

male = [true, false].sample

if male
    puts "We use name John"
else
    puts "We use name Victoria"
end

The program uses a random number generator to simulate our case.

male = [true, false].sample

With sample, we randomly pick a value from the array.

if male
    puts "We use name John"
else
    puts "We use name Victoria"
end

Depending on the male variable, we print a message. If the male variable is set
to true, we choose name John. Otherwise, we choose name Victoria. Control
structures like if/else statements work with boolean values.

$ ./random_name.rb
We use name Victoria
$ ./random_name.rb
We use name Victoria
$ ./random_name.rb
We use name John
$ ./random_name.rb
We use name John
$ ./random_name.rb
We use name John

Running the program several times.

## Ruby symbols

Symbols are used to represent other objects. Using symbols instead of strings
may save some resources. A symbol is an instance object of a Symbol
class. Symbols are generated by using an colon before an identifier, like
:name. Several objects also have to_sym
methods. These methods convert those objects to symbols.

A Ruby symbol cannot be changed at runtime. Ruby symbols are often used as hash
keys, because we do not need full capabilities of a string objects for a key.

symbols.rb
  

#!/usr/bin/ruby

p :name
p :name.class
p :name.methods.size
p "Jane".methods.size

p :name.object_id
p :name.object_id
p "name".object_id
p "name".object_id

In the first example, we show some basic operations with Ruby symbols.

p :name
p :name.class

We print a symbol and its class to the console. The class of the symbol
is Symbol.

p :name.methods.size
p "Jane".methods.size

We compare the number of methods associated with instances of symbols
and strings. A string has more than twice as many methods than symbol.

p :name.object_id
p :name.object_id
p "name".object_id
p "name".object_id

Same symbols have the same id. Same strings have different ids.

$ ./symbols.rb
:name
Symbol
86
183
71068
71068
60
80

This is a sample output.

Symbols may be used as flags. Constants may be used in such situations as well.
In C/C++ we would use enumerations.

symbols2.rb
  

#!/usr/bin/ruby

light = :on

if light == :on
    puts "The light is on"
else
    puts "The light is off"
end

light = :off

if light == :on
    puts "The light is on"
else
    puts "The light is off"
end

A light is either on or off. For both states we might define symbols.

light = :on

The light is on.

if light == :on
    puts "The light is on"
else
    puts "The light is off"
end

The logic of the program depends on the state of the
light variable.

Symbols are often used as keys in hash containers. They
are more efficient that strings.

symbols3.rb
  

#!/usr/bin/ruby

domains = {:sk =&gt; "Slovakia", :no =&gt; "Norway", :hu =&gt; "Hungary"}

puts domains[:sk]
puts domains[:no]
puts domains[:hu]

In the script we have a domains hash. The keys in the hash
are symbols.

puts domains[:sk]
puts domains[:no]
puts domains[:hu]

Keys are used to access values of a hash. Here we print three
values of a hash.

$ ./symbols3.rb
Slovakia
Norway
Hungary

Ruby interpreter stores some references internally as symbols.

symbols4.rb
  

#!/usr/bin/ruby

class Being

    def initialize
        @is = true
    end

    def say
        "I am being"
    end
end

b = Being.new

p b.method :say
p b.instance_variable_get :@is

A Being class is defined. The class has a custom
instance variable @is and a say method.
These two entities are stored using symbols by Ruby.

p b.method :say

The method method looks up a receiver method with
a given name in the b object. We look for a
:say symbol.

p b.instance_variable_get :@is

We use instance_variable_get to check if @is is
an instance variable of the b object. Internally the
variable is stored as an :@is symbol.

$ ./symbols4.rb
#&lt;Method: Being#say() ./symbols4.rb:9&gt;
true

All symbols are stored in a symbol table. In the next example, we look at the
table. The all_symbols method of a Symbol class
returns an array of all symbols from the table.

symbols5.rb
  

#!/usr/bin/ruby

def info
  "info method"
end

@v = "Ruby"

class Some
  @@n = "16"
end

p Symbol.all_symbols.include? :info
p Symbol.all_symbols.include? :@v
p Symbol.all_symbols.include? :@@n

A method, an instance variable and a class variable are created in a Ruby
script. We check if these entities are stored in a symbol table.

p Symbol.all_symbols.include? :info

We check if the :info symbol is in the symbol table. The
line returns true.

$ ./symbols5.rb
true
true
true

All three symbols are present in the Ruby symbol table.

## Ruby integers

Integers are a subset of the real numbers. They are written without a fraction
or a decimal component. Integers fall within a set Z = {..., -2, -1, 0, 1, 2,
...} This set is infinite.

In computer languages, integers are primitive data types. In practice, computers
can only work with a subset of integer values, due to computers' having finite
capacity. Integers are used to count discrete entities. We can have 3, 4 or 6
humans, but we cannot have 3.33 humans. We can have 3.33 kilograms.

Unlike in languages like Java or C, integers in Ruby are objects.

integers.rb
  

#!/usr/bin/ruby

p -2
p 121
p 123265
p -34253464356
p 34867367893463476

p 1.class
p 23453246.class
p 234532423563456346.class
p 2345324235632363463456456346.class

p 5 / 2
p 5.div 2

In this example, we deal with integers.

p -2
p 121
p 123265
p -34253464356
p 34867367893463476

These are positive and negative integer values of various sizes.

p 1.class
p 23453246.class
p 234532423563456346.class
p 2345324235632363463456456346.class

We print the classes of these integers. 

p 5 / 2
p 5.div 2

The two lines show integer division. When we divide two integers using the
integer division operator/method, the result is an integer as well.

$ ./integers.rb
-2
121
123265
-34253464356
34867367893463476
Integer
Integer
Integer
Integer
2
2

Integers can be specified in different *notations* in
Ruby: decimal, hexadecimal, octal, and binary. Decimal numbers are used normally,
as we know them. Hexadecimal numbers are preceded with 0x characters,
octal with 0 character and binary with 0b characters.

inotations.rb
  

#!/usr/bin/ruby

puts 122
puts 0x7a
puts 0172
puts 0b1111010

In the code example, we print decimal 122 in all these notation.

$ ./inotations.rb
122
122
122
122

Ouput of the example.

If we work with integers, we deal with discrete entities. We would use integers
to count apples.

apples.rb
  

#!/usr/bin/ruby

baskets = 16
apples_in_basket = 24

total = baskets * apples_in_basket

puts "There are total of #{total} apples"

In our program, we count the total amount of apples. We work
with integers.

$ ./apples.rb
There are total of 384 apples

The output of the program.

Big numbers are difficult to read. If we have a number like 245342395423452, we
find it difficult to read quickly. Outside computers, big numbers are separated
by spaces or commas. For readability, Ruby allows integers to contain
underscores. Underscores in integers are ignored by the Ruby interpreter.

underscore.rb
  

#!/usr/bin/ruby

p 23482345629
p 23_482_345_629

p 23482345629 == 23_482_345_629

The example demonstrates this use of underscores.

p 23482345629 == 23_482_345_629

This line shows that the two numbers are equal.
It prints true.

$ ./underscore.rb
23482345629
23482345629
true

## Ruby floating point numbers

Floating point numbers represent real numbers in computing. Real numbers measure
continuous quantities like weight, height or speed. In Ruby,
decimal numbers are objects of the Float
or a BigDecimal class. The BigDecimal class, a Ruby core
class, is part of Ruby's standard library. In addition, we can use
Rational objects too.

We need to understand that decimal numbers are not precise. The official Ruby
documentation clearly says that float objects represent inexact real numbers.

decimals.rb
  

#!/usr/bin/ruby

p 15.4
p 0.3455
p -343.4563

p 12.5.class
p -12.5.class
p (5.0 / 2).class

p 5.fdiv 2
p 12.to_f

In the above program, we work with floating point values.

p 15.4
p 0.3455
p -343.4563

Here we print three decimal values. Decimal numbers have a decimal point
character.

p 12.5.class
p -12.5.class
p (5.0 / 2).class

The above code lines show the types of the numbers. All are floats.
Integer division applied on at least one Float produces
a Float too.

p 5.fdiv 2
p 12.to_f

Here we create floating point values by using the floating point fdiv
division method and the conversion to_f method.

$ ./decimals.rb
15.4
0.3455
-343.4563
Float
Float
Float
2.5
12.0

By default, a decimal number is shown with a maximum 16 numbers after the
decimal point. We can control the format of floating point values with the
sprintf or printf methods.

format_float.rb
  

#!/usr/bin/ruby

p 1/3.0
p 1.fdiv 2

puts sprintf "%.4f" % (1/3.0)
puts sprintf "%.7f" % (5/3.0)

Formatting decimal numbers.

p 1/3.0
p 13.fdiv 4
p 1.fdiv 2

The first line prints a decimal with 16 places after
the point. The second line prints two numbers after the
point and the third one.

puts sprintf "%.4f" % (1/3.0)
puts sprintf "%.7f" % (5/3.0)

Here we control the number of values after the decimal point
using the sprintf method. There is a precision in
the format specifier of the sprintf method. It is
a number following the % character. The f
is a conversion specifier that says we are dealing with floating point values.

$ ./format_float.rb
0.3333333333333333
3.25
0.5
0.3333
1.6666667

Ruby supports the use of scientific notation for floating point values. Also
known as exponential notation, it is a way of writing numbers too large or small
to be conveniently written in standard decimal notation.

scientific.rb
  

#!/usr/bin/ruby

p 1.2e-3
p 0.0012

p 1.5E-4
p 0.00015

The example shows two decimal numbers written in scientific notation.

$ ./scientific.rb
0.0012
0.0012
0.00015
0.00015

As we have already stated, floating point values are slightly
inaccurate.  For many computations, ordinary floating point numbers are
sufficiently precise: e.g. if it is not that important if our weight
is 60kg or 60.000023kg. For other computations, including many scientific
and engineering applications, precision is paramount.

Ruby has a BigDecimal in the standard library. This
class provides arbitrary precision for very large or very accurate
floating point numbers.

big_decimal.rb
  

#!/usr/bin/ruby

require 'bigdecimal'

sum = 0

1000.times do
    sum = sum + 0.0001
end

p sum

sum = BigDecimal("0")

1000.times do
    sum = sum + BigDecimal("0.0001")
end

puts sum.to_s('F')
puts sum.to_s('E')

In this simple example, we compare the precision of a
Float compared to a BigDecimal.

require 'bigdecimal'

The BigDecimal class must be imported.

sum = 0

1000.times do
    sum = sum + 0.0001
end

p sum

We form a loop, where we add a small floatig point value
to a sum variable. In the end, there will be a small inaccuracy.

sum = BigDecimal("0")

1000.times do
    sum = sum + BigDecimal("0.0001")
end

We do the same loop with the BigDecimal values.

puts sum.to_s('F')
puts sum.to_s('E')

The sum is printed in floting point and engineering notation.

$ ./big_decimal.rb
0.10000000000000184
0.1
0.1e0

The output shows that the computing with BigDecimal is more
precise than with Floats.

Let's say a sprinter for 100m ran 9.87s. What is his speed in km/h?

sprinter.rb
  

#!/usr/bin/ruby

distance = 0.1
time = 9.87 / 3600

speed = distance / time

puts "The average speed of a sprinter is #{speed} km/h"

In this example, it is necessary to use floating point values.

distance = 0.1

100m is 0.1 km.

time = 9.87 / 3600

9.87s is 9.87/60*60 h.

speed = distance / time

To get the speed, we divide the distance by the time.

$ ./sprinter.rb
The average speed of a sprinter is 36.474164133738604 km/h

## Ruby rational Numbers

Ruby supports rational numbers. A rational number is an exact
number. Using rational numbers we avoid rounding errors.
In Ruby, a rational number is an object of the Rational
class. We can create rational numbers with a special to_r
method from some objects.

A rational number is any number that can be expressed as a fraction
of two integers a/b , where b!=0. Since b may be equal to 1, every
integer is a rational number.

rationals.rb
  

#!/usr/bin/ruby

puts 2.to_r
puts "23".to_r
puts 2.6.to_r

p Rational 0
p Rational 1/5.0
p Rational 0.5

This example shows a few rational numbers.

puts 2.to_r

Here we convert a 2 integer to 2/1 rational number using the
to_r method.

p Rational 0.5

We create a rational number with the Rational class.

$ ./rationals.rb
2/1
23/1
5854679515581645/2251799813685248
(0/1)
(3602879701896397/18014398509481984)
(1/2)

## Ruby nil value

Ruby has a special value nil. It is an absence of a value.
The nil is a singleton object of a NilClass.
There is only one nil; we cannot have more of it.

nil_value.rb
  

#!/usr/bin/ruby

puts nil
p nil

p $val

p [1, 2, 3][4]

p $val1 == $val2

An example with the nil value.

puts nil
p nil

We print the nil value to the console. The
puts method prints an empty string; the
p method prints 'nil' string.

p $val

When we refer to a global variable that was not set,
we get the nil value.

p [1, 2, 3][3]

In this code line, we refer to the fourth element of
a three-element array. We get nil. Many methods
in Ruby return nil for invalid values.

p $val1 == $val2

The line returns true. This is a consequence of the fact that
the nil value is a singleton object of a NilClass.

$ ./nil_value.rb

nil
nil
nil
true

## Ruby strings

A *string* is a data type representing textual data in computer programs.
A Ruby string is a sequence of unicode characters. A string is an instance of
the String. String literals are characters enclosed in double
or single qoutes.

A string is a very important data type. It deserves a dedicated chapter.
Here we include just a small example.

strings.rb
  

#!/usr/bin/ruby

p "Ruby"
p 'Python'

p "Ruby".size
p "Ruby".upcase

p 23.to_s

In this program, we work with Ruby strings. We use the p
method for printing because we see the data type on output.

p "Ruby"
p 'Python'

We print two string literals to the terminal. The first literal
is enclosed in double quotes, the second literal in single quotes.

p "Ruby".size
p "Ruby".upcase

These two lines call two string methods. The size method
returns the size of the string: 4 characters in our case. The upcase
returns the string in uppercase letters.

p 23.to_s

The to_s method converts an integer to a string.

$ ./strings.rb
"Ruby"
"Python"
4
"RUBY"
"23"

In the output we see strings enclosed in quotes. This is the consequence
of using the p method. The print and puts
methods don't do this.

## Ruby arrays and hashes

Arrays and hashes are collections of objects. They group objects into one place.

Arrays are ordered collections of objects. Hashes are collections of key-value
pairs. We have a single chapter for both arrays and hashes. The following
example just gives a quick look at both containers.

arrays_hashes.rb
  

#!/usr/bin/ruby

nums = [1, 2, 3, 4]

puts "There are #{nums.size} items in the array"

nums.each do |num|
    puts num
end

domains = { :de =&gt; "Germany", :sk =&gt; "Slovakia",
            :us =&gt; "United States", :no =&gt; "Norway" }

puts domains.keys
puts domains.values

This is a quick example for a Ruby array and hash.

nums = [1, 2, 3, 4]

puts "There are #{nums.size} items in the array"

nums.each do |num|
    puts num
end

These lines create an array having 4 items. In the second
line we count the items of the array and incorporate it in
the message. Later we go through the array with the each
method and print each of the elements to the console.

domains = { :de =&gt; "Germany", :sk =&gt; "Slovakia",
            :us =&gt; "United States", :no =&gt; "Norway" }

puts domains.keys
puts domains.values

Here we create a Ruby hash. Then we print its keys and values.

$ ./arrays_hashes.rb
There are 4 items in the array
1
2
3
4
de
sk
us
no
Germany
Slovakia
United States
Norway

## Ruby conversions

We often work with multiple data types at once. Converting one data
type to another one is a common job in programming. *Type conversion*
or *typecasting* refers to changing an entity of one data type
into another. There are two types of conversion: implicit and explicit.
Implicit type conversion, also known as coercion, is an automatic type
conversion by the compiler. Ruby has only explicit conversion.

Ruby has built-in conversion methods
like to_i, to_s or to_f.
The Kernel module has a few public methods for
doing conversions, like Integer, String
or Float. These methods should not be confused with
Ruby classes.

conv_methods.rb
  

#!/usr/bin/ruby

p Array(1..6)
p Complex 6
p Float 12
p Integer "34"
p Rational 6
p String 22

Here we show the Kernel conversion methods.

$ ./conv_methods.rb
[1, 2, 3, 4, 5, 6]
(6+0i)
12.0
34
(6/1)
"22"

conversions.rb
  

```
#!/usr/bin/ruby

p "12".to_i
p 12.5.to_i
p nil.to_i

p 12.to_f
p "11".to_f
p nil.to_f

```

In the above example, we show some numerical conversions.
Some Ruby objects have to_i and to_f
methods which convert objects to integers and floats, respectively.

p "12".to_i
p 12.5.to_i
p nil.to_i

In this code we convert a string, decimal, and nil to integer type.

p 12.to_f
p "11".to_f
p nil.to_f

These three lines convert an integer, string, and nil to an object of
decimal data type.

$ ./conversions.rb
12
12
0
12.0
11.0
0.0

The second example shows some string conversions.

string_conv.rb
  

#!/usr/bin/ruby

p "12".to_i
p "13".to_f
p "12".to_r
p "13".to_c

p "Jane".to_sym

v = "Ruby Python Tcl PHP Perl".split
p v.class

In the above example we convert strings to objects of different data types.

p "12".to_i
p "13".to_f
p "12".to_r
p "13".to_c

Here strings are converted to integer, decimal, rational, and
complex numbers.

p "Jane".to_sym

A string becomes a symbol.

v = "Ruby Python Tcl PHP Perl".split
p v.class

Here we use a split method of the String
class to convert a string to an array.

$ ./string_conv.rb
12
13.0
(12/1)
(13+0i)
:Jane
Array

And this is what we get.

The next small example shows array hash conversions.

hash2array.rb
  

#!/usr/bin/ruby

h = {:de =&gt; "Germany", :sk =&gt; "Slovakia"}
p h.to_a

a = [:de, "Germany", :sk, "Slovakia",
     :hu, "Hungary", :no, "Norway"]
p Hash[*a]

In the example code, we create a hash and covert it to array. Then we create an
array and convert it to a hash.

h = {:de =&gt; "Germany", :sk =&gt; "Slovakia"}
p h.to_a

A hash is created and converted to an array using the to_a method.

a = [:de, "Germany", :sk, "Slovakia",
     :hu, "Hungary", :no, "Norway"]
p Hash[*a]

An array is created and converted to a hash. The asterisk in this context is a
splat operator. It is one of the Ruby idioms taken from Perl. It splits an array
into a few variables.

$ ./hash2array.rb
[[:de, "Germany"], [:sk, "Slovakia"]]
{:de=&gt;"Germany", :sk=&gt;"Slovakia", :hu=&gt;"Hungary", :no=&gt;"Norway"}

In this part of the Ruby tutorial, we covered data types and their conversions.

[Contents](..)
[Previous](../objects/)
[Next](../strings/)